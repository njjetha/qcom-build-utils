name: Qualcomm Build Debian Package Reusable Workflow
on:
  workflow_call:
    inputs:
      ref:
        description: The ref name thad was used to invoke this reusable workflow
        type: string
        required: true
      use_local_ppa:
        description: 'Whether to use a local PPA for testing'
        type: boolean
        required: false
        default: true
      clear_ppa: # Assuming this might also be an input for the reusable workflow
        description: 'Whether to clear the PPA'
        type: boolean
        required: false
        default: false
    secrets:
      ACTIONS_SSH_KEY:
        required: true

permissions:
  contents: read
  security-events: write

env:
  PPA_URL: https://qualcomm-linux.github.io/qcom-oss-staging-ppa/

  # This variable is set to true below if the ABI check is not able to find an initial
  # version of the package in the PPA.
  INITIAL_UPLOAD_TO_PPA: 'false'
  ABI_CHECK_RETURN_VALUE: 0

  PRODUCT_DISTRO: null
  PRODUCT_CODENAME: null
  PRODUCT_ARCH: null

  PPA_PACKAGES_FILE_REPO_PATH: null

jobs:
  build-debian-package-reusable-workflow:

    runs-on: [self-hosted, Linux, ARM64]

    steps:

      - name: Ensure Workspace Is Clean
        run: rm -rf * # Ensure workspace is clean from previous runs

      # This checkout is done so that any change in qcom-build-utils doesnt't need to be propagated up
      # Simply relaunching a job that uses this reusable workflow for a given ref will automatically see the changes
      - name: Checkout Tip of qcom-build-utils For The Specified Ref
        uses: actions/checkout@v4
        with:
          repository: qualcomm-linux/qcom-build-utils
          ref: ${{ inputs.ref }}
          ssh-key: ${{ secrets.ACTIONS_SSH_KEY }}
          path: ./qcom-build-utils
          fetch-depth: 1

      - name: Checkout Repository And Submodules Recursively
        uses: actions/checkout@v4 # Using public GitHub action to checkout repo, see https://github.com/actions/checkout
        with:
          ref: ${{ github.head_ref }}
          clean: false # A rm -rf * was done first, don't clean otherwise this would delete qcom-build-utils cloned above
          submodules: 'recursive' # Make sure all submodules are recursively checked out
          ssh-key: ${{ secrets.ACTIONS_SSH_KEY }} # Add SSH key for cloning private repos
          fetch-depth: 1 # Speedup things since full history isn't needed

      - name: Exctract Product Configuration From qcom-product.conf
        run: |
          CONFIG_FILE="qcom-distro-ubuntu/qcom-product.conf"

          DISTRO=$(grep '^Distro:' "$CONFIG_FILE" | cut -d':' -f2 | xargs)
          CODENAME=$(grep '^Codename:' "$CONFIG_FILE" | cut -d':' -f2 | xargs)
          ARCH=$(grep '^Arch:' "$CONFIG_FILE" | cut -d':' -f2 | xargs)

          echo "Distro: $DISTRO"
          echo "Codename: $CODENAME"
          echo "Arch: $ARCH"

          echo "PRODUCT_DISTRO=${DISTRO}" >> $GITHUB_ENV
          echo "PRODUCT_CODENAME=${CODENAME}" >> $GITHUB_ENV
          echo "PRODUCT_ARCH=${ARCH}" >> $GITHUB_ENV

          echo "PPA_PACKAGES_FILE_REPO_PATH=dists/$CODENAME/stable/main/binary-$ARCH" >> $GITHUB_ENV

        # The build.py script expects a specific directory structure
        # This step creates the required directories and links the example package sources to the expected location
        # The build_deb script will go through the WORKSPACE/sources directory and find every "debian" folder and exctract the package names
        # from the Control file and build a list of available packages to build.
      - name: Prepare Workspace Structure For The Build
        run: |
            echo "Listing the content of what was checked out, exclusing .md files : "; tree -I '*.md|LICENSE.txt'
            mkdir WORKSPACE
            mkdir WORKSPACE/sources
            mkdir WORKSPACE/sources/${{ github.event.repository.name }}
            cp -r debian/ WORKSPACE/sources/${{ github.event.repository.name }}
            cp -r qcom-example-package-source WORKSPACE/sources/${{ github.event.repository.name }}

      - name: Validate Or Create Chroot Environment
        run: |
          ./qcom-build-utils/scripts/prep_chroot_env.py \
            --arch        ${{ env.PRODUCT_ARCH }} \
            --os-codename ${{ env.PRODUCT_CODENAME }} \
            --suffix      ${{ env.PRODUCT_DISTRO }}

      - name: Build Debian Packages
        run: |
          ./qcom-build-utils/scripts/build.py \
            --workspace ./WORKSPACE \
            --gen-debians

      - name: ABI Check
        run: |
          set +e

          ./qcom-build-utils/scripts/deb_abi_checker.py \
            --new-package-dir ./WORKSPACE/debian_packages/temp/${{ github.event.repository.name }} \
            --apt-server-config "deb [arch=${{ env.PRODUCT_ARCH }} trusted=yes] ${{ env.PPA_URL }} ${{ env.PRODUCT_CODENAME }}/stable main" \
            --result-file ./results.txt

          RET=$?
          set -e

          echo "ABI check returned $RET"

          #       (0):  RETURN_ABI_NO_DIFF
          # Bit 0 (1):  RETURN_ABI_COMPATIBLE_DIFF
          # Bit 1 (2):  RETURN_ABI_INCOMPATIBLE_DIFF
          # Bit 2 (4):  RETURN_ABI_STRIPPED_PACKAGE
          # Bit 3 (8):  RETURN_PPA_PACKAGE_NOT_FOUND
          # Bit 4 (16): RETURN_PPA_ERROR

          if (( RET == 0 )); then
            echo "✅ ABI check returned NO_DIFF"
          fi

          if (( RET & 1 )); then
            echo "⚠️ABI check returned COMPATIBLE DIFF"
          fi

          if (( RET & 2 )); then
            echo "⚠️ABI check returned INCOMPATIBLE DIFF"
          fi

          if (( RET & 4 )); then
            echo "❌ ABI check returned STRIPPED PACKAGE"
            exit 1
          fi

          if (( RET & 8 )); then
            echo "⚠️ABI check failed because the PPA did not contained an old version for the package."
            echo "Assumption is that this is the first time the package was build."
            echo "INITIAL_UPLOAD_TO_PPA=true" >> $GITHUB_ENV
          fi

          if (( RET & 16 )); then
            echo "❌ ABI check failed because there was an error on the PPA"
            exit 1
          fi

          echo "ABI_CHECK_RETURN_VALUE=${RET}" >> $GITHUB_ENV

      - name: Package Version Increment Check
        if: ${{ env.INITIAL_UPLOAD_TO_PPA == 'false' }}
        run: |
          echo "Run package version check here with ret value ${{ env.ABI_CHECK_RETURN_VALUE }}"
          echo "Content of result file :"
          cat ./results.txt          

          if grep -qE '^\s*-\s*Version:\s*.*FAIL' ./results.txt; then
            echo "❌ Test failed: At least one FAIL found in - Version: line"
            exit 1
          else
            echo "✅ Test passed: All versions are PASS"
          fi

      - name: Checkout PPA staging repo
        if: ${{ env.INITIAL_UPLOAD_TO_PPA == 'true' }}
        uses: actions/checkout@v4
        with:
          repository: qualcomm-linux/qcom-oss-staging-ppa
          ref: main
          ssh-key: ${{ secrets.ACTIONS_SSH_KEY }}
          path: ./qcom-oss-staging-ppa
          fetch-depth: 1

      - name: Upload Debian Packages To PPA Server If First Build
        if: ${{ env.INITIAL_UPLOAD_TO_PPA == 'true' }}
        run: |
          echo "Uploading Debian Package To PPA Server : ${{ env.PPA_URL }}"
          
          for dir in ./WORKSPACE/debian_packages/oss/*/; do
            PACKAGE=$(basename $dir)
            echo "Creating directory for package $PACKAGE" in the PPA
            mkdir -p ./qcom-oss-staging-ppa/pool/${{env.PRODUCT_CODENAME}}/stable/main/$PACKAGE

            echo "Packages to copy for $PACKAGE: "; ls ./WORKSPACE/debian_packages/oss/$PACKAGE

            cp ./WORKSPACE/debian_packages/oss/$PACKAGE/* ./qcom-oss-staging-ppa/pool/${{env.PRODUCT_CODENAME}}/stable/main/$PACKAGE
          done

          cd ./qcom-oss-staging-ppa

          dpkg-scanpackages --multiversion pool/${{ env.PRODUCT_CODENAME }} > ${{ env.PPA_PACKAGES_FILE_REPO_PATH }}/Packages
          dpkg-scanpackages --type ddeb --multiversion pool/${{ env.PRODUCT_CODENAME }} >> ${{ env.PPA_PACKAGES_FILE_REPO_PATH }}/Packages

          gzip -k -f ${{ env.PPA_PACKAGES_FILE_REPO_PATH }}/Packages

          cat ${{ env.PPA_PACKAGES_FILE_REPO_PATH }}/Packages

          git add .
          
          #TODO craft decent message
          git commit -s -m "Uploaded Packages"

          git push