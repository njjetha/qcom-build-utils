name: Qualcomm Build Debian Package Reusable Workflow
on:
  workflow_call:
    inputs:
      ref:
        description: The ref name thad was used to invoke this reusable workflow
        type: string
        required: true
      use_local_ppa:
        description: 'Whether to use a local PPA for testing'
        type: boolean
        required: false
        default: true
      clear_ppa: # Assuming this might also be an input for the reusable workflow
        description: 'Whether to clear the PPA'
        type: boolean
        required: false
        default: false
    secrets:
      ACTIONS_SSH_KEY:
        required: true

permissions:
  contents: read
  security-events: write

env:
  PPA_HTTP_DIRECTORY: /var/www/html/github-actions-ppa
  PPA_HTTP_SERVER_PORT: 12345
  PPA_HTTP_SERVER_SCREEN_NAME: github-actions-ppa-http-server

  # This variable is set to true below if the ABI check is not able to find an initial
  # version of the package in the PPA.
  INITIAL_UPLOAD_TO_PPA: 'false'
  ABI_CHECK_RETURN_VALUE: 0

  PRODUCT_DISTRO: null
  PRODUCT_CODENAME: null
  PRODUCT_ARCH: null

  PPA_PACKAGES_FILE_DIR: null

jobs:
  build-debian-package-reusable-workflow:

    runs-on: [self-hosted, Linux, ARM64]

    steps:

      - name: Ensure Workspace Is Clean
        run: rm -rf * # Ensure workspace is clean from previous runs

      # This checkout is done so that any change in qcom-build-utils doesnt't need to be propagated up
      # Simply relaunching a job that uses this reusable workflow for a given ref will automatically see the changes
      - name: Checkout Tip of qcom-build-utils For The Specified Ref
        uses: actions/checkout@v4
        with:
          repository: qualcomm-linux/qcom-build-utils
          ref: ${{ inputs.ref }}
          ssh-key: ${{ secrets.ACTIONS_SSH_KEY }}
          path: qcom-build-utils
          fetch-depth: 1

      - name: Checkout Repository And Submodules Recursively
        uses: actions/checkout@v4 # Using public GitHub action to checkout repo, see https://github.com/actions/checkout
        with:
          ref: ${{ github.head_ref }}
          clean: true # Make sure the workspace is cleaned up from previous runs
          submodules: 'recursive' # Make sure all submodules are recursively checked out
          ssh-key: ${{ secrets.ACTIONS_SSH_KEY }} # Add SSH key for cloning private repos
          fetch-depth: 1 # Speedup things since full history isn't needed

      - name: Exctract Product Configuration From qcom-product.conf
        run: |
          CONFIG_FILE="qcom-distro-ubuntu/qcom-product.conf"

          DISTRO=$(grep '^Distro:' "$CONFIG_FILE" | cut -d':' -f2 | xargs)
          CODENAME=$(grep '^Codename:' "$CONFIG_FILE" | cut -d':' -f2 | xargs)
          ARCH=$(grep '^Arch:' "$CONFIG_FILE" | cut -d':' -f2 | xargs)

          echo "Distro: $DISTRO"
          echo "Codename: $CODENAME"
          echo "Arch: $ARCH"

          echo "PRODUCT_DISTRO=${DISTRO}" >> $GITHUB_ENV
          echo "PRODUCT_CODENAME=${CODENAME}" >> $GITHUB_ENV
          echo "PRODUCT_ARCH=${ARCH}" >> $GITHUB_ENV

          echo "PPA_PACKAGES_FILE_DIR=${{env.PPA_HTTP_DIRECTORY}}/dists/$CODENAME/stable/main/binary-$ARCH" >> $GITHUB_ENV

      - name: Clear PPA If Requested
        if: ${{ inputs.clear_ppa == true }}
        run: |
          rm -rf ${{ env.PPA_HTTP_DIRECTORY }}/*
          echo "Directory ${{ env.PPA_HTTP_DIRECTORY }} removed"

      - name: Verify Local Test HTTP PPA Server Is Running
        run : |
          echo "Check if PPA serving folder exists ${{ env.PPA_HTTP_DIRECTORY }}"
          if [ -d "${{ env.PPA_HTTP_DIRECTORY }}" ]; then
            echo "Directory exists"
          else
            echo "Directory does not exist"
            mkdir ${{ env.PPA_HTTP_DIRECTORY }}
          fi

          echo "Check if PPA html server is running"

          if screen -list | grep -q "${{ env.PPA_HTTP_SERVER_SCREEN_NAME }}"; then
            echo "Screen session ${{ env.PPA_HTTP_SERVER_SCREEN_NAME }} already exists. Skipping server start."
          else
            screen -dmS ${{ env.PPA_HTTP_SERVER_SCREEN_NAME }} bash -c 'python3 -m http.server ${{ env.PPA_HTTP_SERVER_PORT }} --directory ${{ env.PPA_HTTP_DIRECTORY }}'
            echo "Started HTTP server in screen session ${{ env.PPA_HTTP_SERVER_SCREEN_NAME }}"
          fi

          echo "Check if PPA server works"
          if curl --silent --output /dev/null --fail http://localhost:${{ env.PPA_HTTP_SERVER_PORT }}/; then
            echo "HTTP server works"
          else
            echo "Error: HTTP server is not responding. Exiting"
            exit 1
          fi

          echo "Check if PPA server is populated"
          if [ -f "${{ env.PPA_PACKAGES_FILE_DIR }}/Packages.gz" ]; then
            echo "PPA server is populated, listing the content of Packages:"
            cat ${{ env.PPA_PACKAGES_FILE_DIR }}/Packages
          else
            echo "Error: PPA server is not populated. Populating"
            mkdir -p ${{ env.PPA_PACKAGES_FILE_DIR }}
            dpkg-scanpackages ${{ env.PPA_HTTP_DIRECTORY }} > ${{ env.PPA_PACKAGES_FILE_DIR }}/Packages
            gzip -9 < ${{ env.PPA_PACKAGES_FILE_DIR }}/Packages > ${{ env.PPA_PACKAGES_FILE_DIR }}/Packages.gz
          fi

      - name: Prepare Workspace Structure For The Build
        # The build.py script expects a specific directory structure
        # This step creates the required directories and links the example package sources to the expected location
        # The build_deb script will go through the WORKSPACE/sources directory and find every "debian" folder and exctract the package names
        # from the Control file and build a list of available packages to build.
        run: |
            echo "Listing the content of what was checked out, exclusing .md files : "; tree -I '*.md|LICENSE.txt'
            mkdir WORKSPACE
            mkdir WORKSPACE/sources
            mkdir WORKSPACE/sources/${{ github.event.repository.name }}
            cp -r debian/ WORKSPACE/sources/${{ github.event.repository.name }}
            cp -r qcom-example-package-source WORKSPACE/sources/${{ github.event.repository.name }}

      - name: Validate Or Create Chroot Environment
        run: |
          ./qcom-distro-ubuntu/qcom-build-utils/ubuntu/prep_chroot_env.py \
            --arch        ${{ env.PRODUCT_ARCH }} \
            --os-codename ${{ env.PRODUCT_CODENAME }} \
            --suffix      ${{ env.PRODUCT_DISTRO }}

      - name: Build Debian Packages
        run: |
          ./qcom-distro-ubuntu/qcom-build-utils/ubuntu/build.py \
            --workspace ./WORKSPACE \
            --gen-debians

      - name: ABI Check
        run: |
          set +e

          ./qcom-distro-ubuntu/qcom-build-utils/ubuntu/deb_abi_checker.py \
            --new-package-dir ./WORKSPACE/debian_packages/temp/${{ github.event.repository.name }} \
            --apt-server-config "deb [arch=${{ env.PRODUCT_ARCH }} trusted=yes] http://localhost:${{ env.PPA_HTTP_SERVER_PORT }} ${{ env.PRODUCT_CODENAME }}/stable main" \
            --result-file ./results.txt

          RET=$?
          set -e

          echo "ABI check returned $RET"

          #       (0):  RETURN_ABI_NO_DIFF
          # Bit 0 (1):  RETURN_ABI_COMPATIBLE_DIFF
          # Bit 1 (2):  RETURN_ABI_INCOMPATIBLE_DIFF
          # Bit 2 (4):  RETURN_ABI_STRIPPED_PACKAGE
          # Bit 3 (8):  RETURN_PPA_PACKAGE_NOT_FOUND
          # Bit 4 (16): RETURN_PPA_ERROR

          if (( RET == 0 )); then
            echo "✅ ABI check returned NO_DIFF"
          fi

          if (( RET & 1 )); then
            echo "⚠️ABI check returned COMPATIBLE DIFF"
          fi

          if (( RET & 2 )); then
            echo "⚠️ABI check returned INCOMPATIBLE DIFF"
          fi

          if (( RET & 4 )); then
            echo "❌ ABI check returned STRIPPED PACKAGE"
            exit 1
          fi

          if (( RET & 8 )); then
            echo "⚠️ABI check failed because the PPA did not contained an old version for the package."
            echo "Assumption is that this is the first time the package was build."
            echo "INITIAL_UPLOAD_TO_PPA=true" >> $GITHUB_ENV
          fi

          if (( RET & 16 )); then
            echo "❌ ABI check failed because there was an error on the PPA"
            exit 1
          fi

          echo "ABI_CHECK_RETURN_VALUE=${RET}" >> $GITHUB_ENV

      - name: Package Version Increment Check
        if: ${{ env.INITIAL_UPLOAD_TO_PPA == 'false' }}
        run: |
          echo "Run package version check here with ret value ${{ env.ABI_CHECK_RETURN_VALUE }}"
          echo "Content of result file :"
          cat ./results.txt          

          if grep -qE '^\s*-\s*Version:\s*.*FAIL' ./results.txt; then
            echo "❌ Test failed: At least one FAIL found in - Version: line"
            exit 1
          else
            echo "✅ Test passed: All versions are PASS"
          fi


      - name: Upload Debian Packages To PPA Server If First Build
        if: ${{ env.INITIAL_UPLOAD_TO_PPA == 'true' }}
        run: |
          echo "Uploading Debian Package To PPA Server..."
          cp -r ./WORKSPACE/debian_packages/oss/ ${{ env.PPA_HTTP_DIRECTORY }}
          echo "Copied, here is the new tree of the PPA :"; tree ${{ env.PPA_HTTP_DIRECTORY }}

          echo "Removing olf Packages/.gz files"

          rm -f ${{ env.PPA_PACKAGES_FILE_DIR }}/Packages || true
          rm -f ${{ env.PPA_PACKAGES_FILE_DIR }}/Packages.gz || true

          echo "Updating the Packages/.gz files"

          touch ${{ env.PPA_PACKAGES_FILE_DIR }}/Packages

          for dir in ${{ env.PPA_HTTP_DIRECTORY }}/oss/*/; do
            echo "Updating packages for dir $dir"
            dpkg-scanpackages "$dir" | sed 's|/var/www/html/github-actions-ppa/||'             >> "${{ env.PPA_PACKAGES_FILE_DIR }}/Packages"
            dpkg-scanpackages --type ddeb "$dir" | sed 's|/var/www/html/github-actions-ppa/||' >> "${{ env.PPA_PACKAGES_FILE_DIR }}/Packages"
          done

          gzip -9 < "${{ env.PPA_PACKAGES_FILE_DIR }}/Packages" > "${{ env.PPA_PACKAGES_FILE_DIR }}/Packages.gz"

          echo "Updated the packages.gz files"

          echo "Updated the Packages files for suite: ${{ env.PRODUCT_CODENAME }}"